# 有意思的前端面试题

最近在参加腾讯暑期实习生面试的时候，被问了一个题，题目是这样的：

```javascript
let a = 1;
a.toString();
```

面试官问的是“变量`a`为什么能调用`toString()`方法？”。

反正我当时是想了想，然后回答的是：“在调用时，会沿着`a`的原型链查找，直到找到`toString()`方法。”，然后面试官说：“`a`是原始值，也不是个对象，怎么找它的原型链呢？”然后我就懵了。

下来之后，想深入研究一下这个问题，但却发现，甚至都没法在搜索引擎中输入这个对问题的描述。但好在在《JavaScript高级程序设计》里找到了答案。

书上是这么说的：

> 为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：`Boolean`、`Number`和`String`。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性是，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子：
>
> ```javascript
> let s1 = "some text";
> let s2 = s1.substring(2);
> ```
>
> 在这里，`s1`是一个包含字符串的变量，它是一个原始值。第二行紧接着在`s1`上调用了`substring()`方法，并把结果保存在`s2`中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问`s1`时，是以读模式访问的，也就是从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下3步：
>
> 1. 创建一个`String`类型的实例；
> 2. 调用实例上的特定方法；
> 3. 销毁实例。
>
> 可以把这3步想象成执行了如下3行ECMAScript代码：
>
> ```javascript
> let s1 = new String("some text");
> let s2 = s1.substring(2);
> s1 = null;
> ```
>
> 这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上3步也会在后台发生，只不过使用的是`Boolean`和`Number`包装类型而已。

了解完以上内容，就可以解决最开始的面试题了。当以读模式访问变量`a`时，会先创建与`a`对应的`Number`包装类型的实例，然后调用该实例上的`toString()`方法。

但这是不是意味着可以像操作对象一样任意地给原始类型变量添加删除属性呢？不是的。接着来看书上的内容：

> 引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过`new`实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。比如下面的例子：
>
> ```javascript
> let s1 = "some text";
> s1.color = "red";
> consolel.log(s1.color);  // undefined
> ```
>
> 这里的第二行代码尝试给字符串`s1`添加一个`color`属性。可是，第三行代码访问`color`属性时它却不见了。原因就是第二行代码运行时会临时创建一个`String`对象，而当第三行代码执行时，这个对象已经被销毁了。实际上，第三行代码在这里创建了自己的`String`对象，但这个对象没有`color`属性。

可以显式地使用`Boolean`、`Number`和`String`构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用`typeof`会返回`object`，所有原始值包装对象都会转换为布尔值`true`。虽然不推荐显式创建原始值包装类型的实例，但它们对于操作原始值的功能是很重要的。每个原始值包装类型都有相应的一套方法来方便数据操作。

