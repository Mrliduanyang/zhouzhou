# 二分法应用

## 

提到二分法，很多人第一时间想到的肯定是应用在对有序数据的查找上，但转念一想，是不是也可以用来解决判定问题。一个最简单的例子就是我们经常玩的猜大小游戏，我们通常会往中间数值上来猜，比如第一次猜1，被告知猜小了，第二次猜100，被告知猜大了，那么在猜第三次的时候，我们可能就会去猜一个处在1和100中间的数值，比如50。不断重复上述过程，从而逐渐接近答案。是不是觉得很不可思议，我们竟然从小就会二分法了。接下来我们来看几道二分法解决判定问题的例子，分别是LeetCode上的：

- #### [LeetCode 875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)

- #### [LeetCode 1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)

- #### [LeetCode 1482. 制作 m 束花所需的最少天数](https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/)

## [LeetCode 875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)

> 珂珂喜欢吃香蕉。这里有`N`堆香蕉，第`i`堆中有`piles[i]`根香蕉。警卫已经离开了，将在`H`小时后回来。
>
> 珂珂可以决定她吃香蕉的速度`K`（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉`K`根。如果这堆香蕉少于`K `根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  
>
> 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
>
> 返回她可以在`H`小时内吃掉所有香蕉的最小速度`K`（`K` 为整数）。
>
> **示例 1：**
>
> **输入：**piles = [3,6,7,11], H = 8
> **输出：**4
>
> **示例 2：**
>
> **输入：**piles = [30,11,23,4,20], H = 5
> **输出：**30
>
> **示例 3：**
>
> **输入：**piles = [30,11,23,4,20], H = 6
> **输出：**23

先想想，是不是还是一个猜数字游戏呢？首先，存在一个吃香蕉的最小速度，一次就只吃一根；也存在一个最大速度，题目限制了珂珂一个小时之内只能选择一堆香蕉吃，所以最大速度就是数量最大的那堆香蕉的数量。

知道了最小速度和最大速度以后就好办了，接下来我们就按照猜数字游戏的思路来寻找一个合适的速度，珂珂按照这个速度来吃恰好可满足题目要求。但在此之前，我们还需要解决一个问题，回想猜数字游戏，在我们猜完数字以后，会得到一个反馈，告诉我们猜的结果是大了还是小了。我们同样也要实现类似的功能函数，函数要能返回我们猜测的速度是大了还是小了。

直接看代码：

```c#
public int MinEatingSpeed(int[] piles, int h) {
  	// 最小速度
    var left = 1;
  	// 最大速度
    var right = piles.Max();
  	// 二分法框架，左闭右开
    while (left < right) {
      	// 猜测的中间速度
        var mid = left + (right - left) / 2;
      	// 按照mid速度，吃饭所有香蕉所需的时间
        var need = piles.Sum(pile => (pile - 1) / mid + 1);
				// 二分法收缩边界。因为我们寻找的是最小速度，所以是寻找左边界的二分法写法，即当need == h时，也收缩右边界
        if (need <= h) {
            right = mid;
        }
        else {
            left = mid + 1;
        }
    }
    return left;
}
```



## [LeetCode 1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)

> 传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。
>
> 传送带上的第`i` 个包裹的重量为`weights[i]`。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。
>
> 返回能在`D`天内将传送带上的所有包裹送达的船的最低运载能力。
>
> **示例 1：**
>
> **输入：**weights = [1,2,3,4,5,6,7,8,9,10], D = 5
> **输出：**15
> **解释：**
> 船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
> 第 1 天：1, 2, 3, 4, 5
> 第 2 天：6, 7
> 第 3 天：8
> 第 4 天：9
> 第 5 天：10
>
> 请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 
>
> **示例 2：**
>
> **输入：**weights = [3,2,2,4,1,4], D = 3
> **输出：**6
> **解释：**
> 船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：
> 第 1 天：3, 2
> 第 2 天：2, 4
> 第 3 天：1, 4
>
> **示例 3：**
>
> **输入：**weights = [1,2,3,1,1], D = 4
> **输出：**3
> **解释：**
> 第 1 天：1
> 第 2 天：2
> 第 3 天：3
> 第 4 天：1, 1

看代码：

```c#
public int ShipWithinDays(int[] weights, int D) {
  	// 最小运力
    var left = weights.Max();
  	// 最大运力
    var right = weights.Sum();
  	// 二分法框架，左闭右开
    while (left < right) {
        // 猜测的中间运力
        var mid = left + (right - left) / 2;
      	// 按照mid运力，运完包裹所需要的时间
        int need = 1, cur = 0;
        foreach (var weight in weights) {
            if (cur + weight > mid) {
                ++need;
                cur = 0;
            }
            cur += weight;
        }
				// 二分法收缩边界。因为我们寻找的是最低运力，所以是寻找左边界的二分法写法，即当need == D时，也收缩右边界
        if (need <= D) {
            right = mid;
        }
        else {
            left = mid + 1;
        }
    }
    return left;
}
```

## [LeetCode 1482. 制作 m 束花所需的最少天数](https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/)

> 给你一个整数数组`bloomDay`，以及两个整数`m`和` k`。
>
> 现需要制作`m`束花。制作花束时，需要使用花园中**相邻的`k`朵花** 。
>
> 花园中有`n`朵花，第`i`朵花会在`bloomDay[i]`时盛开，**恰好**可以用于**一束**花中。
>
> 请你返回从花园中摘`m`束花需要等待的最少的天数。如果不能摘到`m`束花则返回**-1** 。
>
> **示例 1：**
>
> **输入：**bloomDay = [1,10,3,10,2], m = 3, k = 1
> **输出：**3
> **解释：**让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。
> 现在需要制作 3 束花，每束只需要 1 朵。
> 1 天后：[x, _, _, _, _]   // 只能制作 1 束花
> 2 天后：[x, _, _, _, x]   // 只能制作 2 束花
> 3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3
>
> **示例 2：**
>
> **输入：**bloomDay = [1,10,3,10,2], m = 3, k = 2
> 输出：-1
> **解释：**要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。
>
> **示例 3：**
>
> **输入：**bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
> **输出：**12
> **解释：**要制作 2 束花，每束需要 3 朵。
> 花园在 7 天后和 12 天后的情况如下：
> 7 天后：[x, x, x, x, _, x, x]
> 可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。
> 12 天后：[x, x, x, x, x, x, x]
> 显然，我们可以用不同的方式制作两束花。
>
> **示例 4：**
>
> **输入：**bloomDay = [1000000000,1000000000], m = 1, k = 1
> **输出：**1000000000
> **解释：**需要等 1000000000 天才能采到花来制作花束
>
> **示例 5：**
>
> **输入：**bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2
> **输出：**9

看代码：

```c#
public int MinDays(int[] bloomDay, int m, int k) {
    if (m > bloomDay.Length / k) {
        return -1;
    }
		
  	// 验证mid天能否完成制作
    bool Check(int mid) {
        var bouquets = 0;
        var flowers = 0;
        var length = bloomDay.Length;
        for (var i = 0; i < length && bouquets < m; i++) {
            if (bloomDay[i] <= mid) {
                flowers++;
                if (flowers == k) {
                    bouquets++;
                    flowers = 0;
                }
            }
            else {
                flowers = 0;
            }
        }
        return bouquets >= m;
    }
		// 最少天数
    var left = bloomDay.Min();
  	// 最大天数
    var right = bloomDay.Max();
  	// 二分法框架，左闭右开
    while (left < right) {
      	// 猜测的中间天数
        var mid = left + (right - left) / 2;
      	// 二分法收缩边界。因为我们寻找的是最低运力，所以是寻找左边界的二分法写法
        if (Check(mid)) {
            right = mid;
        }
        else {
            left = mid + 1;
        }
    }

    return low;
}
```

