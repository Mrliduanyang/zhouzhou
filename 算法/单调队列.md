# 【算法】LeetCode分享（单调队列+滑动窗口）

## 0.单调队列

在使用单调队列之前，可以根据之前分享的单调栈文章来理解单调队列的原理和特性。单调队列相对于单调栈的区别是，单调栈只能从栈顶出栈，而单调队列可以从队首和队尾出队。既然可以在队首和队尾操作元素，那么我们可以想象一下如下的操作：

- 队尾入队，队首出队：很像滑动窗口的操作。
- 队尾出队，队尾入队：单调队列的操作。

所以我们可以发现，单调队列可以和滑动窗口结合起来，用来解决滑动窗口内元素最值的问题。

## 1.单调队列实战

### 1.1  [LeetCode 239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。
>
> 返回滑 动窗口中的最大值。
>
> **示例 1：**
>
> **输入：**nums = [1,3,-1,-3,5,3,6,7], k = 3
> **输出：**[3,3,5,5,6,7]
> **解释：**
> 滑动窗口的位置                最大值
>
> ---------------               -----
> [1  3  -1] -3  5  3  6  7       3
>  1 [3  -1  -3] 5  3  6  7       3
>  1  3 [-1  -3  5] 3  6  7       5
>  1  3  -1 [-3  5  3] 6  7       5
>  1  3  -1  -3 [5  3  6] 7       6
>  1  3  -1  -3  5 [3  6  7]      7
>
> **示例 2：**
>
> **输入：**nums = [1], k = 1
> **输出：**[1]
>
> **示例 3：**
>
> **输入：**nums = [1,-1], k = 1
> 输出：[1,-1]

套用第0节中滑动窗口和单调队列的操作，我们可以使用一个双端队列，用队尾入队、队首出队来存储滑动窗口内的元素，并用队尾出队、队尾入队来维持队列中元素的单调性以记录最值。所以我们可以写出解决该问题的代码。

```csharp
public int[] MaxSlidingWindow(int[] nums, int k) {
    int n = nums.Length;
    int[] res = new int[n - k + 1];
    // 使用链表模拟双端队列
    LinkedList<int> deque = new LinkedList<int>();
    for (int i = 0; i < n; i++) {
        // 实现单调递减队列
        while (deque.Count != 0 && nums[deque.Last()] <= nums[i]) {
            // 如果队列不为空，并且待入队元素值大于队尾元素值，队尾元素出队，维持队列的单调递减性
            deque.RemoveLast();
        }
        // 队列单调性满足后，新元素队尾入队
        deque.AddLast(i);
        // 实现滑动窗口
        if (deque.First() < (i - k + 1)) {
            // 添加了下标为i的元素后，如果队列中元素的下标范围超过窗口范围k，队首元素出队
            deque.RemoveFirst();
        }
        // 记录最终结果
        if (i >= k - 1) {
            res[i - k + 1] = nums[deque.First()];
        }
    }
    return res;
}
```

### 1.2 [LeetCode 1438. 绝对差不超过限制的最长连续子数组](https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)

> 给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。
>
> 如果不存在满足条件的子数组，则返回 0 。
>
> **示例 1：**
>
> **输入：**nums = [8,2,4,7], limit = 4
> **输出：**2 
> **解释：**所有子数组如下：
> [8] 最大绝对差 |8-8| = 0 <= 4.
> [8,2] 最大绝对差 |8-2| = 6 > 4. 
> [8,2,4] 最大绝对差 |8-2| = 6 > 4.
> [8,2,4,7] 最大绝对差 |8-2| = 6 > 4.
> [2] 最大绝对差 |2-2| = 0 <= 4.
> [2,4] 最大绝对差 |2-4| = 2 <= 4.
> [2,4,7] 最大绝对差 |2-7| = 5 > 4.
> [4] 最大绝对差 |4-4| = 0 <= 4.
> [4,7] 最大绝对差 |4-7| = 3 <= 4.
> [7] 最大绝对差 |7-7| = 0 <= 4. 
> 因此，满足题意的最长子数组的长度为 2 。
>
> **示例 2：**
>
> **输入：**nums = [10,1,2,4,7,2], limit = 5
> **输出：**4 
> **解释：**满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 <= 5 。
>
> **示例 3：**
>
> **输入：**nums = [4,2,2,2,4,4,2,2], limit = 0
> **输出：**3

```csharp
public int LongestSubarray(int[] nums, int limit) {
    int left = 0, right = 0, n = nums.Length;
    // 使用链表模拟双端队列
    var max = new LinkedList<int>();
    var min = new LinkedList<int>();
    while (right < n) {
        // 实现单调递减队列
        while (max.Count > 0 && nums[max.Last()] <= nums[right]) max.RemoveLast();
        // 实现单调递增队列
        while (min.Count > 0 && nums[min.Last()] >= nums[right]) min.RemoveLast();
        // 滑动窗口扩张
        max.AddLast(right);
        min.AddLast(right);
        right++;
        // 维护队列元素下标范围（只需要[left, right]内的元素）
        if (max.First() < left) max.RemoveFirst();
        if (min.First() < left) min.RemoveFirst();
        // 滑动窗口收缩
        if (nums[max.First()] - nums[min.First()] > limit) left++;
    }
    return right - left;
}
```

该题相对于上一题而言，思想没变，仅仅是增加了一个记录区间最小值的单调递增队列。

## 2.总结

在上面两道题目的算法实现细节中，有一点需要注意：

> 为什么找最大值要用单调递减队列，而不用单调递增队列，单调递增队列，大的值在队尾，不是也能找到最大值吗？

用语言来概括就是，单调递减队列中可以保留某个“最大值”之后其他的“最大值”信息。具体的，在单调递减队列中，最大值在队首，最小值在队尾，这样在队尾操作元素维护单调性的时候，不至于把最大值弄丢，可以尽量的保留最大值。举个例子，令239题中的**nums=[1,2,3,4,1,2,3,4]，k=3**，使用单调递增队列来解决该题目。当滑动窗口滑动到子数组**[2,3,4]**时，单调队列中存储**[2,3,4]**，当窗口继续右移**1**位时，子数组为**[3,4,1]**，单调队列中存储**[1]**，我们可以发现，原来队列中的较大值**2,3,4**都在**1**入队的时候被挤掉了，这就导致了最大值结果不正确。

总而言之，我们在解决最大值问题上使用单调递减队列，将大的值存储在靠近队尾的位置，尽可能避免丢失最大值；在解决最小值问题上使用单调递增队列，将小的值存储在靠近队尾的位置，尽可能避免丢失最小值。

