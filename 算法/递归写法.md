# 递归问题解题技巧

LeetCode上的递归类型题目往往都是难度中等，但代码巧妙简洁。本文带大家总结一下递归问题的解题技巧。关于如何分析递归问题，设计递归算法的内容，网上已有很多，这里就不再详细讲解。

## 0.递归问题简要分析

根据个人总结，递归程序应用最广泛的场景就是树，而所用的算法又往往是深度优先。因为树和深度优先遍历的结合实在是太契合。首先，树的每个父节点和他的子节点之间，可以把以子节点为根的子树看做父节点树的子问题，对子树的求解和对父节点树的求解思路完全一致，并且叶子节点子问题的求解可以当作是递归终止条件。这三点完全符合递归使用的三个条件。而深度优先算法又是从一个点出发，往深处去“钻”，“钻”到底之后再往回走，这个过程跟递归的调用过程也是很像的。因此，我们主要采用**树+深度优先**类型的题目来讲解递归技巧。

## 1.递归问题求解

拿到一道**树+深度优先**的题目后，几乎可以肯定这题是能用递归来解的，所以接下来的难点就是设计递归函数。而在设计递归函数的时候，个人总结了四点设计原则：

- 确定递归函数有无返回值。
- 确定递归函数的功能。
- 只关注当下。千万不要铺开模拟递归的过程，找到当前问题和其子问题的关系即可，无需再去研究子问题的求解过程。
- 最大&最小问题验证。用最大规模问题验证递归程序的正确性。用最小规模的问题来验证递归终止条件，并和它的上一级问题一起来验证递归正确性。

## 2.树+深度优先递归实战

### 2.1 [ LeetCode 110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

> 给定一个二叉树，判断它是否是高度平衡的二叉树。
>
> 本题中，一棵高度平衡二叉树定义为：
>
> 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
>
> **示例 1：**
>
> ![img](https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210124160937.jpeg)
>
> **输入：**root = [3,9,20,null,null,15,7]
> **输出：**true
>
> **示例 2：**
>
> ![img](https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210125123111.jpeg)
>
> **输入：**root = [1,2,2,3,3,null,null,4,4]
> **输出：**false
>
> **示例 3：**
>
> **输入：**root = []
> **输出：**true

使用四原则来分析上面的问题。

- 首先，判断以一个节点为根的树是否是平衡二叉树，需要获取它的左右子树的高度，所以可以确定，递归函数是有返回值的，需要返回树的高度、以及树是否是平衡二叉树。
- 其次，递归函数的功能可以确定是获取以传入节点为根的树的高度和判断树的平衡性。
- 然后分析，假如已知一个节点A，它的子节点是B、C，并且已知子树B、C是平衡二叉树且B、C的高度分别是b、c，那么，只要b、c之差的绝对值不大于1，则可以判定A是一个平衡二叉树。
- 最后，易知最大规模问题在该递归程序上求解是正确的，而对于叶子节点的子节点（最小规模问题）来说，它的高度是0，所以叶子节点和它的孩子节点（null）构成的树也是平衡的，验证了正确性和终止条件。

根据以上分析，我们写出解决该问题的递归程序代码。

```csharp
public bool IsBalanced(TreeNode root) {
    // 该递归函数功能是计算树的高度和判断树的平衡性
    (int height, bool isBalanced) Helper(TreeNode root) {
        // 递归终止条件
        if (root == null) {
            return (0, true);
        } else {
            var(lHeight, lBalanced) = Helper(root.left);
            var(rHeight, rBalanced) = Helper(root.right);
            // 当前树的高度等于它的子树中最高的高度+1
            // 当前树的子树高度之差不大于1并且子树都是平衡二叉树，则当前树是一棵平衡二差树
            return (Math.Max(lHeight, rHeight) + 1, Math.Abs(lHeight - rHeight) <= 1 && lBalanced && rBalanced);
        }
    }
    // 初始化调用递归函数
    return Helper(root).isBalanced;
}
```

### 2.2 [LeetCode 543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

> 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
>
> **示例 ：**
> 给定二叉树
>
>               1
>              / \
>             2   3
>            / \     
>           4   5  
> 返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

这道题表面是求树的直径，但本质是要求树的高度。因为根据题目定义，如果在递归程序中返回树的直径，那么父问题是没法根据子问题的解来求的。但如果返回树的高度，那么可以根据子问题的解来获得父问题的解，并且可以间接求得问题的解。

使用四原则来分析上面的问题。

- 首先，计算以一个节点为根的树的直径，需要获取它的左右子树的高度，所以可以确定，递归函数是有返回值的，需要返回树的高度。
- 其次，递归函数的功能可以确定是获取以传入节点为根的树的高度。
- 然后分析，假如已知一个节点A，它的子节点是B、C，并且已知子树B、C的高度分别是b、c，那么，子树A的高度为max(b, c)+1。而子树A的直径为b+c+1。
- 最后，易知最大规模问题在该递归程序上求解是正确的，而对于叶子节点的子节点（最小规模问题）来说，它的直径是0，也就可以确定递归终止条件。

根据以上分析，我们写出解决该问题的递归程序代码。

```csharp
public int DiameterOfBinaryTree(TreeNode root) {
    // 记录全局最大直径
    int ans = 1;
    // 该递归函数功能是计算树的高度
    int Helper(TreeNode root) {
        // 递归终止条件
        if (root == null) {
            return 0;
        }
        int l = Helper(root.left);
        int r = Helper(root.right);
        // 更新全局最大直径
        ans = Math.Max(ans, l + r + 1);
        // 计算以当前节点为根的树高度
        return Math.Max(l, r) + 1;
    }

    Helper(root);
    return ans - 1;
}
```

### 2.3 [LeetCode 965. 单值二叉树](https://leetcode-cn.com/problems/univalued-binary-tree/)

> 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
>
> 只有给定的树是单值二叉树时，才返回 true；否则返回 false。
>
> **示例 1：**
>
> ![img](https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210124204410.png)
>
> **输入：**[1,1,1,1,1,null,1]
> **输出：**true
>
> **示例 2：**
>
> ![img](https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210124204417.png)
>
> **输入：**[2,2,2,5,2]
> 输出：false

使用四原则来分析上面的问题。

- 首先，判断以一个节点为根的树的是否是单值二叉树，需要获取它的左右子树的单值性，所以可以确定，递归函数是有返回值的，需要返回树的单值性。
- 其次，递归函数的功能可以确定是获取以传入节点为根的树的单值性。
- 然后分析，假如已知一个节点A，它的子节点是B、C，并且已知子树B、C都是单值二叉树，那么，只要节点A的值等于指定的值，则A是一个单值二叉树。
- 最后，易知最大规模问题在该递归程序上求解是正确的，而对于叶子节点的子节点（最小规模问题）来说，它单值性为true，所以只要叶子节点值等于指定的值就可以它的孩子节点（null）构成单值二叉树，验证了正确性和终止条件。

根据以上分析，我们写出解决该问题的递归程序代码。

```csharp
public bool IsUnivalTree(TreeNode root) {
    int val = root.val;
    bool Helper(TreeNode root) {
        if (root == null) return true;
        var left = Helper(root.left);
        var right = Helper(root.right);
        return left && right && root.val == val;
    }
    return Helper(root);
}
```

## 3.总结

这三道都是难度为简单的**递归+树+深度优先**套路的题目。对于理解递归的思想很有帮助，并且当想尝试展开递归过程，理解递归细节时也没有太大难度。但当从更抽象的角度来看这三道题，就会发现，这三道题更本质的特征是树的后序遍历，都是先获取了左右子树的结果，然后在根的位置处理左右子树的结果。感兴趣的读者可以想想分治法、递归、深度优先、树、后序遍历之间的关系。后续文章将会给大家带来其他形式的递归问题分析。