# 回溯法总结

本文会引导大家从一个具象的小例子出发来认识回溯法。

![image-20210104132151868](https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210104132211.png)

用一句歌词概括回溯法，那就是**“向左向右向前看”**。图中的小蓝要去找小绿，但是小蓝一开始并不知道小绿在哪里，所以他只能摸索着找。先向左走，找到了小红，但不是他想要的，于是退回来；然后向上走，找到了小黄，可也不是他想要的，只能再次退回来；最后向右走，终于找到了小绿，结束。

## 0.回溯法的本质

先说结论，回溯法的本质是**一棵N叉树的遍历**。N叉树中除叶子节点外每个节点都有N个孩子节点，回到上图，如果将小蓝看做树中节点的话，那小红、小黄、小绿便是小蓝的孩子节点。如果有N个和小蓝同级的节点，并且他们连在同一个父节点上，以此重复，便可得到回溯法的**解空间树**。而小蓝在丁字路口的向左、向上、向右以及退回的操作便相当于回溯法中的**选择和撤销选择**，关于**选择和撤销选择**的概念在后文详解介绍。

## 1.回溯法框架

我们把小蓝找小绿的难度加大，如下图所示：

![image-20210104150336916](https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210104150336.png)

小蓝初始站在Root位置，在他面前是一个十字路口，有1、2、3、4四个方向，并且沿每个方向走，又会遇到丁字路口，分别是5、6，7、8，9、10，11、12。**小蓝的目标是找到12号小绿**。我们先用文字来描述一下搜索过程。

- 进入方向1**（选择）**
- 不是12号小绿**（结束条件）**
  - 进入方向5**（选择）**
  - 不是12号小绿**（结束条件）**
  - 从方向5退回**（撤销选择）**
  - 进入方向6**（选择）**
  - 不是12号小绿**（结束条件）**
  - 从方向6退回**（撤销选择）**
- 从方向1退回**（撤销选择）**
- 进入方向2**（选择）**
- 不是12号小绿**（结束条件）**
  - 进入方向7**（选择）**
  - 不是12号小绿**（结束条件）**
  - 从方向7退回**（撤销选择）**
  - 进入方向8**（选择）**
  - 不是12号小绿**（结束条件）**
  - 从方向8退回**（撤销选择）**
- 从方向2退回**（撤销选择）**
- 方向3和4类似操作

总结这个搜索过程，我们先将同级的操作抽取出来，一共包含4部分：**选择、结束条件、递归调用回溯、撤销选择**，所以用代码来抽象上面这段搜索过程就是：

```csharp
var res = [];
var path = [];
void Backtrack(选择列表) {
    if (path满足结束条件) {
        res.Add(path);
        return;
    }
    for (选择 in 选择列表) {
        path.Add(选择);
        Backtrack(新的选择列表);
        path.Remove(选择);
    }
}

Backtrack(初始选择列表);
```

## 2.回溯法实战

我们基于以上小蓝找小绿的思路和总结的回溯法框架，来解决几道**LeetCode**上的回溯法题目。

### 2.1 [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

> 给定一个无重复元素的数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。
>
> `candidates` 中的数字可以无限制重复被选取。
>
> **说明：**
>
> - 所有数字（包括 `target`）都是正整数。
> - 解集不能包含重复的组合。 
>
> **示例 1：**
>
> **输入：**candidates = [2,3,6,7], target = 7,
> 所求解集为：
> [
>   [7],
>   [2,2,3]
> ]

```csharp
public List<List<int>> CombinationSum(int[] candidates, int target) {
    // candidates中无重复元素，但每个元素可用无限次
    var path = new List<int>();
    var res = new List<List<int>>();

    void Helper(int begin, int sum) {
        // 搜索结束条件，如果path中元素之和==target，说明path是一个有效答案
        if (sum == target) {
            res.Add(path.ToList());
            return;
        }
        // begin用来指示本次回溯的选择起点，去重的关键
        for (int i = begin; i < candidates.Length; i++) {
            // 剪枝处理，减少不必要的回溯
            if ((sum + candidates[i]) <= target) {
                // 选择
                path.Add(candidates[i]);
                // 递归调用回溯。因为candidates中元素可以无限次使用，所以在下一次选择时，依旧可以从当前元素开始
                Helper(i, sum + candidates[i]);
                // 撤销选择
                path.RemoveAt(path.Count - 1);
            } else {
                break;
            }
        }
    }
    
    if (candidates.Length == 0) {
        return res;
    }
    Helper(0, 0);
    return res;
}
```

需要额外说的一点是关于代码中结果去重的处理，组合类问题是不区分顺序的，也就是说`[1, 2]`和`[2, 1]`是一个结果。去重的关键是在每次递归调用回溯时，新的选择列表从当前元素下标`i`开始，而不是从`0`开始。接下来分析，为什么这样处理可以去重。

假如`candidates = [1, 2, 3, 5, 7]; target = 6`，递归到第一层时的选择列表是`[1, 2, 3, 5, 7]`，我们选择下标`0`位置的元素`1`，以`1`为选择的第二层递归从位置`0`开始选择，所以选择列表还是`[1, 2, 3, 5, 7]`，我们可以选择下标`1`位置的元素`2`，同样的，以`2`为选择的第二层递归从位置`1`开始选择，所以第三次选择列表是`[2, 3, 5, 7]`，我们可以选择`3`，这样我们就得到了一个`[1, 2, 3]`的答案。但如果在递归调用时选择列表都从`0`开始，即每次的选择列表都是`[1, 2, 3, 6, 7]`，那么会出现这样的情况，第一层递归时选择了`2`，第二层选择`3`，第三层选择`1`，得到`[2, 3, 1]`的答案；第一层选择了`3`，第二层选择`2`，第三层选择`1`，得到`[3, 2, 1]`的答案，但这两组答案是重复的。但如果加入新的选择列表从当前元素下标`i`开始的约束，就可以保证选择时不会选中当前元素之前的元素，从而避免上面的重复情况。

### 2.2 [46. 全排列](https://leetcode-cn.com/problems/permutations/)

> 给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。
>
> **示例:**
>
> **输入：** [1,2,3]
> **输出：**
> [
>   [1,2,3],
>   [1,3,2],
>   [2,1,3],
>   [2,3,1],
>   [3,1,2],
>   [3,2,1]
> ]

```csharp
public List<int[]> Permute(int[] nums) {
    var res = new List<int[]>();
    var path = new List<int>();
    
    void Helper() {
        if (path.Count == nums.Length) {
            // 搜索结束条件，如果nums中所有元素都在path中，说明找到一个全排列
            res.Add(path.ToArray());
            return;
        }
        foreach (var num in nums) {
            // 剪枝处理，如果路径中已存在元素num，则跳过
            // 这里的剪枝不是很高效，可以用hash表来记录该元素是否被添加过
            if (path.Contains(num)) {
                continue;
            }
            // 做选择
            path.Add(num);
            // 递归调用回溯
            Helper();
            // 撤销选择
            path.RemoveAt(path.Count - 1);
        }
    }
    
    Helper();
    return res;
}
```

### 2.3 [78. 子集](https://leetcode-cn.com/problems/subsets/)

> 给你一个整数数组 `nums` ，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。
>
> **示例 1：**
>
> **输入：**nums = [1,2,3]
> **输出：**[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
>
> **示例 2：**
>
> **输入：**nums = [0]
> **输出：**[[],[0]]

```csharp
public List<List<int>> Subsets(int[] nums) {
    var path = new List<int>();
    var res = new List<List<int>>();

    void Helper(int begin) {
        // 搜索结束条件，任意一个路径都是一个子集
        res.Add(path.ToList());
        for (int i = begin; i < nums.Length; i++) {
            // 选择
            path.Add(nums[i]);
            // 递归调用回溯，新的选择列表为当前元素位置之后的所有元素，所以在下一次选择时，从当前元素的下一个开始
            Helper(i + 1);
            // 撤销选择
            path.RemoveAt(path.Count - 1);
        }
    }
    
    if (nums.Length == 0) {
        return res;
    }
    Helper(0);
    return res;
}
```

## 3总结

回溯法的框架很容易记住，但是针对每道题的细节处理会是一个很令人困扰的地方。在本文的实战部分，只给大家分享了三道经典的回溯法题目，分别是组合、排列、子集类的问题。至于他们的变种问题，更难的N皇后问题、解数独，以及回溯法中的细节处理，将在之后的文章中和大家分享。

